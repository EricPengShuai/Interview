## 快手

### 数据库

#### 1. MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？

- 磁盘读写代价更低：B+ 树非叶子节点只存储索引，不存储数据，B+ 树更矮
- 查询效率更加稳定，并且叶子节点采用双链表连接，更加适合范围查询



#### 2. 简述一致性哈希算法的实现方式及原理

一致性哈希解决的问题就是分布式系统扩容或者缩容时，避免过多的数据迁移

- 将「存储节点」和「数据」都哈希映射到一个首尾相连的哈希环上，对一个固定的数比如 2^32-1 取哈希
- 数据顺时针方向找到的第一个节点就是该数据的存储节点



#### 3. 简述什么是最左匹配原则

联合索引



#### 4. 为什么 Redis 在单线程下能如此快？ [参考1](https://redis.io/topics/benchmarks)

==ToDo==



#### 5. MySQL 联合索引底层原理是什么？

按照索引项 a b c 的顺序 B+ 树存储



#### 6. 数据库的事务隔离级别有哪些？各有哪些优缺点？

- 未提交读：读到最新的数据
- 提交读：避免脏读
- 可重复度：避免不可重复读
- 可串行化：加锁实现



#### 7. Redis 如何实现分布式锁？ [参考1](https://redis.io/topics/distlock) [参考2](https://www.redis.com.cn/topics/distlock.html)

==ToDo==



#### 8. 什么情况下会发生死锁，如何解决死锁？

死锁是指在多线程或多进程环境下，两个或多个线程或进程由于互相等待对方释放资源而无法继续执行的状态。死锁可能会导致系统停滞，造成资源浪费，降低系统性能。

死锁发生的条件通常包括以下四个方面，也被称为死锁产生的必要条件：

1. **互斥条件**（Mutual Exclusion）：资源只能被一个线程或进程占用，其他线程或进程无法同时访问。
2. **请求和保持条件**（Hold and Wait）：线程或进程在持有某个资源的同时，又请求其他资源，但又被其他线程或进程持有，导致相互等待。
3. **不可剥夺条件**（No Preemption）：资源不能被强制性地剥夺，只能由占有资源的线程或进程自行释放。
4. **环路等待条件**（Circular Wait）：存在一系列线程或进程之间的资源占用链，形成环路，使得每个线程或进程都在等待下一个资源被释放。

解决死锁的方法主要有以下几种：

1. 预防死锁：通过设计合理的资源分配策略，破坏死锁产生的必要条件，如避免线程或进程同时请求多个资源，或者要求线程或进程在请求资源时释放已经占有的资源。
2. 避免死锁：通过使用资源分配算法，在分配资源时考虑避免死锁的可能性，如**银行家算法**（Banker's algorithm），该算法通过对资源请求进行动态检查，避免产生死锁。
3. 检测死锁：通过周期性地检查系统状态，判断是否存在死锁，如果检测到死锁，可以通过回滚操作或者终止某些进程或线程来解除死锁。
4. 解除死锁：当检测到死锁时，可以采取解除死锁的措施，如剥夺某些线程或进程的资源，或者通过协调线程或进程的资源请求顺序来解除死锁。



#### 9. Redis 有几种数据结构？Zset 是如何实现的？ [参考1](https://redis.io/topics/data-types) [参考2](https://www.redis.com.cn/redis-data-types.html)

==ToDo==



#### 10. 简述常见的负载均衡算法

- 轮询法：按照请求顺序轮流分配资源
- 随机法：根据后端服务器列表大小值随机选取其中一台访问，随着调用量增大最后也是轮询的效果
- 源地址哈希法：获取客户端访问的IP，通过哈希函数计算哈希值
- 加权轮询法：按照权重轮询，配置高，负载低的机器配置更高的权重
- 加权随机法
- 最小连接法



#### 11. 简述 MySQL 的主从同步机制，如果同步失败会怎么样？

主从同步的基本工作流程如下：

1. 主服务器将写入的数据更新记录到二进制日志（Binary Log，或称为 Binlog）中，这是一种记录数据库写操作的日志。
2. 从服务器通过连接到主服务器，并发送复制请求，请求从主服务器获取二进制日志中的更新记录。
3. 主服务器将二进制日志中的更新记录传送给从服务器，从服务器将这些记录应用到自己的数据库中，实现数据的同步。

如果主从同步失败，可能会导致以下情况：

1. 数据不一致：主服务器和从服务器上的数据可能不一致，从服务器的数据可能落后于主服务器，导致数据的不一致性。
2. 业务中断：如果从服务器无法正常同步主服务器的数据，可能导致从服务器无法提供正常的读取请求，从而影响业务的正常运行。
3. 数据丢失：如果主服务器上的二进制日志损坏或丢失，从服务器将无法获取到更新记录，导致数据丢失。



#### 12. MySQL中 InnoDB 和 MylSAM 的区别是什么？

- InnoDB**支持事务**，可以进行Commit和Rollback；

- MyISAM 只支持表级锁，而 InnoDB 还**支持行级锁**，提高了并发操作的性能；

- InnoDB **支持外键**和**热备份**；

- MyISAM **崩溃**后发生损坏的概率比 InnoDB 高很多，而且**恢复的速度**也更慢；

- MyISAM 支持**压缩**表和空间数据索引，InnoDB需要更多的内存和存储；

  

#### 13. 聚簇索引和非聚簇索引有什么区别？

- 聚簇索引叶子结点存储实际数据
- 非聚簇索引存储主键值



#### 14. 简述乐观锁以及悲观锁的区别以及使用场景

- 乐观锁：乐观地认为不会发生并发一致性问题，适用于读多写少的场景，通过版本号解决冲突
- 悲观锁：悲观地认为会出现并发一致性问题，适用于写频繁的场景，通过加锁来避免冲突



#### 15. 简述 MySQL 常见索引类型，介绍一下[覆盖索引](https://www.huaweicloud.com/articles/dcb82f6f898a10e3d4c24926d890f4c6.html)

```mysql
select ID from T where k between 3 and 5;
```

由于查询的值是ID，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里，索引k已经“覆盖了”我们的查询需求，故称为**覆盖索引**

**总结**：覆盖索引就是从辅助索引中就能**直接**得到查询结果，而不需要回表到聚簇索引中进行再次查询，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说减少IO操作（通过辅助索引树可以一次性从磁盘载入更多节点），从而提升性能。



#### 16. 如何设计数据库压测方案？

1. 确定测试目标和预测的测试结果

2. 选择合适的数据库压测工具：JMeter、ab、sysbench、TPC Benchmark
3. 准备测试数据以及测试环境



#### 17. Redis 的 String 数据类型是如何实现的？

==ToDo==



### 操作系统

#### 1. 进程间有哪些通信方式？

- 管道(Pipe)/命名管道

- 消息队列

- [信号](https://www.jianshu.com/p/c1015f5ffa74) (Signal)

  - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
  - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
  - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

  > **Linux系统中常用信号：**  
  > （1）`SIGHUP`：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。  
  > （2）`SIGINT`：程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。  
  > （3）`SIGQUIT`：程序退出信号。程序运行过程中，按`Ctrl+\\`键将产生该信号。  
  > （4）`SIGBUS/SIGSEGV`：进程访问非法地址。  
  > （5）`SIGFPE`：运算中出现致命错误，如除零操作、数据溢出等。  
  > （6）`SIGKILL`：用户终止进程执行信号。shell下执行`kill -9`发送该信号。  
  > （7）`SIGTERM`：结束进程信号。shell下执行`kill 进程pid`发送该信号。  
  > （8）`SIGALRM`：定时器信号。  
  > （9）`SIGCLD`：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。  

- 共享内存

- 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态

- 套接字(Socket)



#### 2. 简述自旋锁与互斥锁的使用场景

- 互斥锁：是一种独占锁，如果线程 A 加锁成功之后，B 想获取互斥锁就会失败，**线程 B 被阻塞进入「睡眠」状态**，释放 CPU 给其他线程，等锁释放之后被唤醒继续执行，这些由**操作系统内核**完成
- 自旋锁：通过 CPU 提供的 Compare And Swap 函数，在「用户态」完成加锁和解锁操作，不会发生线程状态的切换，加锁失败时会一直自旋，**进入「忙等待」直到锁释放**，适用于锁住代码执行时间较短的线程

参考：https://blog.csdn.net/qq_34827674/article/details/108608566



#### 3. 进程和线程之间有什么区别？
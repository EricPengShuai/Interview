## 字节跳动

### 广告部门

> 2020.11.20  一面，后端主要C++，少量Python/Golang

#### C++

##### 1、const是啥，[指针常量和常量指针](https://www.jb51.net/article/86519.htm)，怎样改变函数const声明的变量值


> **其实吧，这种翻译比较难以理解甚至会混淆，直接看表达式就可以了，就两种：一个是指针是常量，一个是指向的对象是常量**

```cpp
// 首先应该明白指针就是地址 
// p是一个常量指针【指向常量的指针】，指向的内容不可以变化，但是可以通过改变地址让它指向另一个常量
const int *p; 或者是 int const *p;

// p是一个指针常量【指针本身是常量】，指向内部存储的内存地址是常量，不可以改变，但是内存地址所对应的内容是可以变化的
int *const p; // 引用的本质是指针常量

void func(const int var);	// 传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)
void func(const char* var);	// 参数指针所指内容为常量不可变
void func(char* const var);	// 参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的)
void func(const class& var);// 引用参数在函数内不可以改变
```



##### 2、volatile关键字

> http://www.cppblog.com/mzty/archive/2006/08/08/10959.html

```cpp
// 修改construction修饰的变量
// https://blog.csdn.net/weixin_41413441/article/details/80860135
const volatile int i = 10；

// https://www.cnblogs.com/gylhaut/p/5502583.html
# include <iostream>
using namespace std;
class TestMutable {
    mutable int i;
public:
    TestMutable() { i=0;}
    int Output() const {
        return i++; 
    }
};
```



##### 3、static是啥，比较，用在那些场景

- **限制符号的作用域只在本程序文件**
- **指定变量的存储位置**: 全局的和函数内定义的**static**变量都是存放在数据区的，且只存一份，只在整个程序结束后才自动释放，其他变量都是存储在栈，函数结束之后就释放
- **C++类的静态成员变量和函数**：静态成员函数中没有**this**指针，只能调用静态成员变量

> 参考：https://www.jianshu.com/p/0b2d9679a9f2



##### 4、遍历一个vector所有元素的方法有哪些

```cpp
vector<int> a;
// for循坏
for(int i = 0; i < a.size(); i++) { 
    cout << a[i] << ' ' << a.at(i);
}

// auto也可以换成vector<int>::const_iterator
for (auto iter = a.begin(); iter != a.end(); iter++) {
	cout << (*iter) << endl;
}

// for_each  cbegin()  cend()
for_each(a.begin(), a.end(), [](int x) {cout << x << ' ';});

// 直接for auto遍历
for (auto& val : valList)
```



##### 5、++i 和 i++ 区别，哪个更快，为什么

- i++ 不能作为左值，而 ++i 可以。
- a++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；++a是直接对于原对象进行自增，然后返回原对象的引用，可以作为左值。
- 由于要生成临时对象，a++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；++a由于不用生成临时变量，且以引用方式返回，故没有构造与析构的开销，效率更高。

```cpp
int i = 0;
int *p1 = &(++i); //正确
int *p2 = &(i++); //错误

++i = 1; //正确
i++ = 5; //错误

cout << ++(++(++i)) << endl;
cout << ++ ++i << endl;
```

> 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值
>
> 左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址
> 
>http://haoqchen.site/2018/10/15/difference-between-++i-i++-i+=1-i=i+1/



#### 计网和OS

##### 1、请求一个网页具体过程

> 本地DNS服务器之前是查找浏览器、操作系统和路由器的DNS缓存，然后是参考[一次完整的HTTP请求过程图](https://github.com/EricPengShuai/Interview/blob/main/Guide/ByteDanceGuide.md#31-一次完整的http请求过程)

##### 2、进程通信方式

> socket忘记了

##### 3、进程和线程区别

> 差点把进程是资源分配的单位、线程是调度的基本单位说反了

##### 4、linux 中 vi 模式的查找命令

> 正则式：命令模式下输入“/字符串”，例如“/hive.sit”
>
> 如果查找下一个，按“n”即可

##### 5、[算法] 有环链表的入口节点

> 双指针，相遇之后，头再起一个指针直到和p1相遇

##### 6、[算法] [1, 3, 1, 6] 四个数字全部都用，使用加减乘除运算怎么得到24

> 3 \* 8 和 4 \* 6



---



### 火山引擎

> 2021.4.23 一面

#### 操作系统

##### 1、进程调度的几个方法，说一下多级反馈队列调度

##### 2、死锁的条件

①互斥；②非抢占资源分配；③持有和等待；④循环等待

##### 3、进程和线程的区别

##### 4、虚拟内存了解吗，段页式了解吗

1. 存储分配方式总体分为：**连续内存分配和离散内存分配**

   <img src="https://img-blog.csdn.net/20131031074819750" style="zoom: 70%"/>

2. 离散分配原因：由于连续分配方式会形成许多内存碎片，虽可通过“紧凑”功能将碎片合并，但会付出很大开销。于是出现离散分配方式：将一个进程直接分散地装入到许多**不相邻**的内存分区中。

3. 离散分配分为：页式、段式、段页式

   1. 页式：大小固定，存在地址覆盖的问题，**将地址空间划分成固定大小的页**，每一页再与内存进行映射。
   2. 段式：大小不固定，每个表分成段，一个段构成一个独立的地址空间。**每个段的长度可以不同，并且可以动态增长**。
   3. 段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

4. 分页与分段的比较

   - 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
   - [地址空间的维度](https://zhidao.baidu.com/question/124136674.html)：**分页是一维地址空间，分段是二维的。**
   - 大小是否可以改变：页的大小不可变，x段的大小可以动态改变。
   - 出现的原因：**分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护**。



#### 计算机网络

##### 1、网页请求过程，三次握手和四次挥手

挥手过程FIN字段是客户端先发一次然后服务器那边再发送一次，**CLOSE_WAIT** 阶段，**TIME_WAIT **阶段

##### 2、get 和 post 携带的 body 区别

1. [POST携带body参数](https://blog.csdn.net/baichoufei90/article/details/84030479)一般有四种：
   - `application/x-www-form-urlencoded`：浏览器的原生form表单，发送之前编码所有字符
   - `multipart/form-data`：使用表单上传文件时，必须让 表单的 Content-Type 等于 multipart/form-data，不对字符编码
   - `application/json`：现在用的比较多的一种JSON字符串，支持格式化数据
   - `text/xml`：用于传输xml个数的数据，比JSON格式复杂臃肿，一般用于配置文件
2. GET 请求的body一般不携带参数的，一般不这么做

##### 3、客户端请求的HTTP字段格式

- 请求行：包括**请求方法、URL字段、HTTP协议版本**三个字段
- 请求头部：由关键字-值对组成
- 空行：发送回车符和换行符，通知服务器以下不再有请求头
- 请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。

##### 4、HTTP响应报文 [参考](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 最后是响应的内容主体



#### 数据库

##### 1、索引种类，底层实现是什么

- [x] **B+树**的各种操作：插入（什么时候分裂），删除（什么时候合并），查找（**目前看到的阶数一般是3**）
  1. 插入：全部在叶子节点上进行，不能破坏关键字的顺序，如果插入之后节点中关键字个数超过3个就需要进行分裂，具体规则可以看[知乎](https://zhuanlan.zhihu.com/p/149287061)
  2. 删除：需要考虑合并过程
  3. 查找
- [x] 行锁和表锁了解吗

  1. **行锁通过索引加载**，即是行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁
  2. **表锁不会出现死锁**，锁冲突的几率高，但是并发低；**行锁会出现死锁**，锁冲突的几率低，并发高
  3. **行锁分为：共享锁和排它锁**，排它锁上锁之后允许其他事物读？



##### 2、[算法] 旋转数组的二分查找问题：重复和不重复



### 搜索部门

> 2021.4.30

#### 一面

##### 1、OSI七层模型、每层相关技术

- 应用层：程序以及接口，文件传输、电子邮件、文件服务、虚拟终端，**HTTP、DNS、FTP、SMTP**
- 表示层：对数据进行转换、加密和压缩，没有协议
- 会话层：建立、管理和终止会话，没有协议
- 传输层：提供可靠的端到端的报文传输和差错控制，**TCP、UDP**
- 网络层： 将分组从源端传送到目的端，为数据包选择路由IP，**ICMP、RIP、OSPF、BGP、IGMP**
- 数据链路层：将分组数据封装成帧；提供节点到节点方式的传输，传输有地址的帧以及错误检测功能，**PPP、ARP、RARP、MTU**
- 物理层：以二进制数据形式在物理媒体上传输数据，物理层：中继器、集线器

<img src="https://img-blog.csdnimg.cn/20181212222104379.png" style="zoom:70%;" />

##### 2、TCP/IP协议

- 应用层
- 传输层：四层交换机
- 网络层：路由器
- 数据链路层：网桥、以太网交换机、网卡（其实一半工作在物理层一半工作在数据链路层）

<img src="https://img-blog.csdnimg.cn/20181212222138685.png" style="zoom:70%;" />

##### 3、TCP 和 OSI 区别：

- **TCP/IP支持跨层封装**；OSI不支持 
- **TCP/IP仅仅支持IP网络协议**; OSI支持多种网络层协议（IP  IPX  APPLE TALK  NOVELL  NSAP）

参考：[参考1](https://blog.csdn.net/qq_43272170/article/details/84980017)、[参考2](http://www.ha97.com/3215.html)、[参考3](https://blog.csdn.net/qq_38872310/article/details/79923253)



##### 4、数据库有哪些隔离级别

未提交读、提交读、可重复读、可串行化



##### 5、[算法] 有环链表

> 牛客上面定义链表都报错：因为牛客、力扣这些平台他自己内部已经有定义了ListNode，所以会报错。TreeNode 同理。
>
> 本质原因：“都显示重复定义了，那就名字和内部的库重复了呗”
>
> 如果有的环境连main都报错的话即是不需要主函数只需要实现方式就可以



### 飞书PC客户端

#### 一面

> 2023.10.24—17:00-18:00 办公套件，终于被捞😭，久违的面试

- 上来直接介绍 muduo 网络库，具体细节

- 替换的 boost 什么依赖，any？bind？

- epoll_wait 等待占用 CPU 吗，分几种情况？

  > 当进程被"阻塞/挂起"时，是不会占用 CPU 资源的
  >
  > 参考：https://www.infoq.cn/article/26LPJzSp9EChwgNIc7Lq

- 线程/进程常见三个状态以及转换关系：就绪、运行、阻塞 [参考](https://blog.csdn.net/xieyutian1990/article/details/38402977)

  <img src="https://pic4.zhimg.com/80/v2-621adf98d0f89458472155dcfe2730bf_720w.webp" style="zoom:80%;" />

- 线程池线程使用完了怎么办，1个 main Reactor 接受 IO 连接，3 个 sub Reactor 已经在处理 3 个相关业务了，此时如果**再来一个连接如何处理**？

  > 还是会 dispatch 给 3 个 subReactor 中的一个，相当于现在一个 EventLoop 处理两个连接中的读写业务

- 其中有哪些线程同步操作，**条件变量、信号量同步哪个效率高一些**

  > - 互斥锁（Mutex）：使用互斥锁可以确保在同一时间只有一个线程可以访问被保护的共享资源。线程在访问共享资源之前需要先获取互斥锁，访问完成后再释放互斥锁，以确保互斥访问
  >
  > - 条件变量（Condition Variable）：条件变量用于线程之间的等待和通知机制。一个线程可以等待某个条件满足，而另一个线程可以在满足条件时通知等待的线程继续执行
  >
  > - 信号量（Semaphore）：信号量是一种计数器，用于控制多个线程对共享资源的访问。它可以限制同时访问的线程数量，通过增加或减少信号量的计数来控制访问权限。
  >
  > - 原子操作（Atomic Operations）：原子操作是一种无需使用锁的同步机制。它们提供了一种保证某些操作是原子性的方式，即不会被其他线程中断。常见的原子操作包括原子加载、存储、比较和交换等
  >
  > - 读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。这样可以提高读操作的并发性能
  >
  > 哪种同步方式效率更高取决于具体的使用场景和需求。不同的同步方式适用于不同的情况，并且其性能也会受到多种因素的影响，如线程数量、竞争程度、共享资源的访问模式等。
  >
  > **一般来说，原子操作的效率较高，因为它们通常不需要使用锁来保护共享资源，而是利用底层硬件提供的原子指令来实现同步。**因此，在并发度较高、对共享资源的访问较为简单的场景下，原子操作可能是较为高效的选择。
  >
  > 另外，**读写锁在读多写少的情况下可以提供更好的性能**，因为它允许多个线程同时读取共享资源，从而提高了读操作的并发性能。
  >
  > 然而，对于具体的应用场景，最好的方式是进行实际的性能测试和评估，以确定最适合的同步方式。此外，还应考虑代码的可维护性、易用性和可扩展性等因素，并根据实际需求进行权衡和选择。

- C++ 常见容器以及对应的使用场景：序列式容器、关联式容器、无序容器、容器适配器

- sort 函数可以排序那些容器

  - 关联式容器无需 sort，自然有序
  - 序列式容器 list 有 sort 成员函数，不能直接调用 sort，因为**算法库的 sort 要求 random access Iterator**，其他的序列式容器 array、vector 和 deque 不具有 sort 成员函数，可以调用 sort 算法库

- 右值引用用途：主要用于避免深拷贝，效率更高，move 原理

- 智能指针相关，**weak_ptr 线程安全吗**？

- 算法：返回链表倒数第 k 个节点



#### 二面

> 2023.10.27—16:00-17:40

- shared_ptr 和 weak_ptr 底层实现，**lock() 是如何做到线程安全的**

  > `weak_ptr.lock()`通过CAS（Compare and Swap）操作实现自旋锁，可以实现原子操作。CAS是一种原子操作，它允许线程比较内存位置的当前值和期望值，如果相等，则修改内存位置为新值。这是一种常见的原子操作，通常由底层硬件提供支持。CAS 操作的一般流程如下：
  >
  > 1. 读取内存位置的当前值，比较当前值与期望值；
  > 2. 如果相等，将新值写入内存位置；
  > 3. 否则，放弃操作，因为内存位置的值已经发生了变化；

- 原子类型了解吗，**底层是如何实现原子变量的 ++ 和 -- 操作的**

  > 通过底层的硬件和编译器支持来实现的，通常使用特定的CPU指令来保证操作的原子性。不同编译器或者不同平台的具体实现可能不同：
  >
  > - **CPU 指令**：许多现代CPU都支持原子操作的硬件指令，如原子增加和原子减少。编译器可以将 `++` 和 `--` 操作映射到这些指令上，以确保操作的原子性。这些硬件指令会锁定内存位置，使其他线程无法在同一时间修改它。
  > - **CAS（Compare-and-Swap）操作**：某些平台不支持硬件原子操作指令，但编译器可以使用CAS操作来实现原子性。CAS是一种基本的并发原子操作，它允许线程比较内存位置的当前值和期望值，如果相等，则修改内存位置为新值。CAS操作通常需要循环，直到成功为止，以确保操作的原子性。
  > - **使用互斥锁**：在一些不支持硬件原子操作或CAS操作的平台上，编译器可能使用互斥锁来实现原子操作。这会带来一些性能开销，因为它需要线程之间的同步，但可以确保操作的原子性。

- 单例模式的线程安全问题，锁+双重检测可以提高效率

- 不同平台的 IO 复用 API 了解多少

  > 1. **POSIX select() 和 poll()**：
  >
  >    **Linux/Unix/macOS**：`select()` 和 `poll()` 在这些平台上是通用的I/O复用接口，并且名称相同。它们使用文件描述符集合来监视多个文件描述符的状态，并在有数据准备好时通知应用程序。
  >
  > 2. **POSIX epoll()**：
  >
  >    **Linux**：`epoll` 是Linux特有的I/O复用接口，相对于 `select` 和 `poll`，它通常更加高效，特别是在大量并发连接的情况下。它使用事件驱动的机制，应用程序可以等待文件描述符上的特定事件，而不是在所有文件描述符上等待变化。
  >
  > 3. **POSIX kqueue()**：
  >
  >    **FreeBSD/macOS**：`kqueue` 是BSD衍生系统上的I/O复用接口，类似于`epoll`。它也使用事件通知机制，允许应用程序监视大量文件描述符上的事件。
  >
  > 4. **Windows IOCP（I/O Completion Ports）**：
  >
  >    **Windows**：Windows上的I/O复用接口是IOCP，它使用事件驱动的模型，并允许应用程序异步地处理I/O操作。IOCP通常被认为在处理大规模并发连接时非常高效。

- lambda 表达式了解吗，可以转化成函数指针吗

  > 可以，参考：https://blog.csdn.net/weixin_42695485/article/details/130810561

- 动态库和静态库了解吗，分别使用两个库编译得到可执行文件，**输入「复杂参数」运行有问题吗**

  > - 静态库编译得到的可执行文件没问题
  > - 动态库编译得到可执行文件可能存在问题，动态库函数实现中的类型可能和「复杂参数」不一致，另外也可能由于编译动态库的系统不同导致运行出错

- muduo 网络库作者是谁，有读过陈硕其他文章吗，C++ 读过哪些书籍






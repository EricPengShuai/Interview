## 广告部门

> 后端主要C++，少量Python/Golang

### 2020.11.20  一面 

#### C++基础问题

1. const是啥，[指针常量和常量指针](https://www.jb51.net/article/86519.htm)，怎样改变函数const声明的变量值

   **其实吧，这种翻译比较难以理解甚至会混淆，直接看表达式就可以了，就两种：一个是指针是常量，一个是指向的对象是常量**
   
   ```cpp
   // 首先应该明白指针就是地址 
   // p是一个指针常量【指向常量的指针】，指向的内容不可以变化，但是可以通过改变地址让它指向另一个常量	
   const int *p; 或者是 int const *p; 
   // p是一个常指针【指针本身是常量】，指向内部存储的内存地址是常量，不可以改变，但是内存地址所对应的内容是可以变化的
   int *const p;	
   const int *const p; // 指向常量的常量指针
   ```

> - void function(const int Var);   //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)
> - void function(const char* Var);  //参数指针所指内容为常量不可变
> - void function(char* const Var);  //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的)
> - void function(const Class& Var); //引用参数在函数内不可以改变
> 
> volatile关键字：http://www.cppblog.com/mzty/archive/2006/08/08/10959.html
> 
> ```c++
>// 修改construction修饰的变量
> // https://blog.csdn.net/weixin_41413441/article/details/80860135
> const volatile int i = 10；
> 
> // https://www.cnblogs.com/gylhaut/p/5502583.html
># include <iostream>
> using namespace std;
>class TestMutable
> {
> public:
>   TestMutable(){i=0;}
>   int Output() const
>   {
>     return i++; 
>   }
> private:
> 	mutable int i;
> };
> ```



2. static是啥，比较，用在那些场景

   https://www.jianshu.com/p/0b2d9679a9f2

- **限制符号的作用域只在本程序文件**
- **指定变量的存储位置**: 全局的和函数内定义的**static**变量都是存放在数据区的，且只存一份，只在整个程序结束后才自动释放，其他变量都是存储在栈，函数结束之后就释放
- **C++类的静态成员变量和函数**：静态成员函数中没有**this**指针，只能调用静态成员变量



3. 遍历一个vector所有元素的方法有哪些

```cpp
vector<int> a;
// for循坏
for(int i = 0; i < a.size(); i++) { 
  cout << a[i];
	cout << a.at(i);
}

// 迭代器iterator  cbegin()  cend()
// auto也可以换成vector<int>::const_iterator
for (auto iter = valList.begin(); iter != valList.end(); iter++)
{
  cout << (*iter) << endl;
}

// for_each  cbegin()  cend()
template<typename T>
void printer(const T& val)
{
	cout << val << endl;
}
void ShowVec(const vector<int>& valList)
{
	for_each(valList.begin(), valList.end(), printer<int>);
}

// 直接for auto遍历
for (auto& val : valList)
{
  cout << val << endl;
}
```





- `++i` 和 `i++`区别，哪个更快，为什么

> i++ 不能作为左值，而++i 可以。
>
> 1. a++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；++a是直接对于原对象进行自增，然后返回原对象的引用，可以作为左值。
> 2. 由于要生成临时对象，a++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；++a由于不用生成临时变量，且以引用方式返回，故没有构造与析构的开销，效率更高。
>
> ```c++
> int i = 0;
> int *p1 = &(++i); //正确
> int *p2 = &(i++); //错误
> 
> ++i = 1; //正确
> i++ = 5; //错误
> 
> cout << ++(++(++i)) << endl;
> cout << ++ ++i << endl;
> ```
>
> 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。
>
> 左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。
>
> http://haoqchen.site/2018/10/15/difference-between-++i-i++-i+=1-i=i+1/



#### 计网和OS

1. 请求一个网页具体过程

   > 本地DNS服务器之前是查找浏览器、操作系统和路由器的DNS缓存，然后是参考[一次完整的HTTP请求过程图](https://github.com/EricPengShuai/Interview/blob/main/interview_summary.md#一次完整的http请求过程)

2. 进程通信方式

   > socket忘记了

3. 进程和线程区别

   > 差点把进程是资源分配的单位、线程是调度的基本单位说反了



**附带一点linux**

1. linux中vi模式的查找命令

   > 正则式：命令模式下输入“/字符串”，例如“/hive.sit”
   >
   > 如果查找下一个，按“n”即可



#### 算法

1. 有环链表的入口节点

   > 双指针，相遇之后，头再起一个指针直到和p1相遇

2. [1, 3, 1, 6]四个数字全部都用，使用加减乘除运算怎么得到24

   > 3 \* 8 和 4 \* 6



#### 反思

很多C++基础问题都不清楚，基础不牢

---



## 火山引擎

### 2021.4.23 一面

#### 操作系统

1. 进程调度的几个方法，说一下多级反馈队列调度
2. 死锁的条件：①互斥；②非抢占资源分配；③持有和等待；④循环等待
3. 进程和线程的区别
4. 虚拟内存了解吗

- [x] 段页式了解吗

  1. 存储分配方式总体分为：**连续内存分配和离散内存分配**

     <img src="https://urlify.cn/BNJZ7v" style="zoom: 70%"/>

  2. 离散分配原因：由于连续分配方式会形成许多内存碎片，虽可通过“紧凑”功能将碎片合并，但会付出很大开销。于是出现离散分配方式：将一个进程直接分散地装入到许多**不相邻**的内存分区中。

  3. 离散分配分为：页式、段式、段页式

     1. 页式：大小固定，存在地址覆盖的问题，**将地址空间划分成固定大小的页**，每一页再与内存进行映射。
     2. 段式：大小不固定，每个表分成段，一个段构成一个独立的地址空间。**每个段的长度可以不同，并且可以动态增长**。
     3. 段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

  4. 分页与分段的比较

     - 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
     - [地址空间的维度](https://zhidao.baidu.com/question/124136674.html)：**分页是一维地址空间，分段是二维的。**
     - 大小是否可以改变：页的大小不可变，x段的大小可以动态改变。
     - 出现的原因：**分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护**。



#### 计算机网络

1. 网页请求过程，三次握手和**四次挥手**（挥手过程FIN字段是客户端先发一次然后服务器那边再发送一次，**CLOSE_WAIT**阶段，**TIME_WAIT**阶段）

- [x] **get和post**携带的body区别
  1. [POST携带body参数](https://urlify.cn/NrUR7r)一般有四种：
     1. `application/x-www-form-urlencoded`：浏览器的原生form表单，发送之前编码所有字符
     2. `multipart/form-data`：使用表单上传文件时，必须让 表单的 Content-Type 等于 multipart/form-data，不对字符编码
     3. `application/json`：现在用的比较多的一种JSON字符串，支持格式化数据
     4. `text/xml`：用于传输xml个数的数据，比JSON格式复杂臃肿，一般用于配置文件
  2. GET 请求的body一般不携带参数的，一般不这么做

- [x] 客户端请求的HTTP字段格式

  1. 请求行：包括**请求方法、URL字段、HTTP协议版本**三个字段
  2. 请求头部：由关键字-值对组成
  3. 空行：发送回车符和换行符，通知服务器以下不再有请求头
  4. 请求数据：请求数据不在GET方法中使用，**而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。**

- [x] HTTP响应报文

  1. 状态行：比如200ok、404Not Found等
  2. 消息报头
  3. 响应正文

  

#### 数据库

1. 索引种类，底层实现是什么

- [x] **B+树**的各种操作：插入（什么时候分裂），删除（什么时候合并），查找（**目前看到的阶数一般是3**）
  1. 插入：全部在叶子节点上进行，不能破坏关键字的顺序，如果插入之后节点中关键字个数超过3个就需要进行分裂，具体规则可以看[知乎](https://zhuanlan.zhihu.com/p/149287061)
  2. 删除：需要考虑合并过程
  3. 查找
- [x] 行锁和表锁了解吗

  1. **行锁通过索引加载**，即是行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁
  2. **表锁不会出现死锁**，锁冲突的几率高，但是并发低；**行锁会出现死锁**，锁冲突的几率低，并发高
  3. **行锁分为：共享锁和排它锁**，排它锁上锁之后允许其他事物读？



#### 算法

1. 旋转数组的二分查找问题：重复和不重复



#### 反思

前面太紧张了，四次挥手过程，段页式也都忘了，没有问语言的知识啊



## 搜索部门

### 2021.4.30

#### 项目

- 一上来直接问项目？真的🐶，没话说
  - 每个模块吧



#### 计算机网络

- [x] **OSI七层模型**、每层相关技术

  - 应用层：程序以及接口，文件传输、电子邮件、文件服务、虚拟终端，**HTTP、DNS、FTP、SMTP**
  - 表示层：对数据进行转换、加密和压缩，没有协议
  - 会话层：建立、管理和终止会话，没有协议
  - 传输层：提供可靠的端到端的报文传输和差错控制，**TCP、UDP**
  - 网络层： 将分组从源端传送到目的端，为数据包选择路由IP，**ICMP、RIP、OSPF、BGP、IGMP**
  - 数据链路层：将分组数据封装成帧；提供节点到节点方式的传输，传输有地址的帧以及错误检测功能，**PPP、ARP、RARP、MTU**
  - 物理层：以二进制数据形式在物理媒体上传输数据，物理层：中继器、集线器

  <img src="https://urlify.cn/yqeUFz" style="zoom:80%;" />

- [x] TCP/IP协议

  - 应用层
  - 传输层：四层交换机
  - 网络层：路由器
  - 数据链路层：网桥、以太网交换机、网卡（其实一半工作在物理层一半工作在数据链路层）

  <img src="https://urlify.cn/EBnERj" style="zoom:70%;" />

- [x] 区别：

  1. **TCP/IP支持跨层封装**；OSI不支持 

  2. **TCP/IP仅仅支持IP网络协议**; OSI支持多种网络层协议（IP  IPX  APPLE TALK  NOVELL  NSAP）

> 参考：
>
> 1. https://blog.csdn.net/qq_43272170/article/details/84980017
> 2. http://www.ha97.com/3215.html
> 3. https://urlify.cn/F7J7Zv



#### 数据库

1. 隔离级别

   > 其实我已经说完了，这个面试官还在那……



#### 算法

1. 有环链表：不是很了解原理

   > 牛客上面定义链表都报错：
   >
   > 因为牛客、力扣这些平台他自己内部已经有定义了ListNode，所以会报错。TreeNode同理。
   >
   > 本质原因：“都显示重复定义了，那就名字和内部的库重复了呗”
   >
   > 如果有的环境连main都报错的话即是不需要主函数只需要实现方式就可以



#### 总结

体验比较差，问题很偏



## Byte camp——计算机视觉

### 2021.6.13

晚上七点半牛客网在线编程，120分钟三道题，感觉特别难（当时复习时候以为就是面试题的难度，结果）



#### 二叉树

- **题目描述**：选择部分节点让他们的和最大，对于某个节点，选择其一个或者子节点之后就不能选择该节点了。（也就是选择孩子之后就不能选择父亲节点）
- **回顾**：当时就连输入都不知道怎么处理，输入是以层序遍历形式给出，当时想了好久，然后二叉树构造出来之后也没有想到这个题目的思路，没做出来



#### 图

- **题目描述**：选择路径最短的一条“路”
- **回顾**：感觉就是考虑一个Floyd算法



#### 座位问题

感觉没有思路
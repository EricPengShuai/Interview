## 百度

### 0313笔试

#### T2 构造字符串 [mid]

输入一个整数 n（1 <= n <= 1e9），输出一个字符串 s（任意符合要求的都可）

- 要求1：s 的字符只能从 {'r', 'e', 'd'} 中选择

- 要求2：s 的回文子串个数为 n

```bash
# 样例
输入：n = 3
输出：s = "rr"（"red"也可以）

输入：n = 4
输出：s = "rre"（"rrd"也可以）
```

> 贪心构造：(rrr...)(eee...)(ddd...)(rrr...)(eee...)(ddd...)...这样构造，长度从长到短
>
> 代码参考：[baidu_0313_2.cpp](./code/baidu_0313_2.cpp)



#### T3 树上同色连通块 [hard]

**题目内容** : 每个节点被染成了红色或者蓝色。小红定义每条边的权值为：删除这条边时，形成的两个子树的同色连通块数量之差的绝对值。小红想知道，所有边的权值之和是多少？

**输入描述** : 第一行输入一个正整数 n，代表节点的数量；第二行输入一个长度为 n 且仅由 R 和 B 种字符组成的字符串；第 i 个字符为 R 代表 i 号节点被染成红色，为 B 则被染成蓝色。接下来的 n−1 行，每行输入两个正整数 u 和 v ，代表节点 u 和节点 v 有一条边相连。1 <= n <= 200000

**输出描述** : 一个正整数，代表所有节点的权值之和。

```bash
# 样例
# 输入：
4
BBRR
1 2
3 2
4 1
# 输出：
2
```

**[思路](https://leetcode.cn/circle/discuss/JXBVCl/)：** `dp[i]` 表示以 i 为根的子树中同色联通块的个数。如果从 1 号节点开始枚举，最后 dp[1] 得到就是整棵树的同色连通块个数，考虑转移方程：

**计算 dp[n]**

base case：节点 i 只有一个子结点 j，$dp[i]=dp[j] + (color[i] \neq color[j])$

> 两种情况：① i 和 j 颜色不同，连通块个数 +1；② i 和 j 颜色相同，连通块个数不变

假设 节点 i 有多个子节点 j，考虑子节点一个一个拼接在节点 i 上，这个过程分阶段进行，反复进行 base case 的转换就可以，得到 $dp[i]=\Sigma dp[j] + (color[i] \neq color[j])$

**计算权值 ans**

枚举每条边 u --> v，断开之后原图分成两个部分，子树部分显然是 dp[v]，而子树的子集就是整体的同色连通块个数 dp[1] - dp[v]，但是需要注意如果两个节点颜色相同，补集同色连通块个数需要 +1，这个过程也可以 dfs 实现

> 代码参考：[baidu_0313_3.cpp](./code/baidu_0313_3.cpp)



### 搜索架构

> 2021.4.26 一面

#### C++

1. C++文本文件到可执行文件的过程：**预编译，编译，汇编，链接**
   - 参考：**hello.c 程序的编译过程**
2. C++的**多态**了解吗
3. **map**和**set**的区别，set中插入相同的值会发生什么



- [x] **红黑树**了解吗，二叉树？
  - **出现原因**：二叉搜索数最极端的情况是退化成链表，查找效率变低，平衡二叉树其实也可以解决效率低的问题，但是他要求每个节点的左右子树的高度差不大于1，因此在大量数据插入或者删除时需要经常调整，效率也不高。
  - 性质：
    - 节点只有黑色和红色
    - 根节点是黑色
    - 每个叶子节点是黑色
    - 每个红色节点的两个子节点一定是黑色，不能有两个红色节点相连
    - 任意一个节点到每个叶子节点的路径都包含数量相同的黑节点，**黑高**
  - 查找：和搜索二叉树相同
  - 插入：插入节点必须是红色



- [x] **new、delete**以及**malloc、free**区别

  - 相同点：都可以用于内存的动态申请和释放

  - 不同点：

    - new/delete是**C++运算符**，支持重载，不需要库文件；malloc/free是C/C++语言标准库函数，支持覆盖，需要库文件

    - new自动计算要分配的空间大小，malloc需要手工计算

    - new是类型安全的，malloc不是

      ```cpp
      int *p = new float[2]; //编译错误 
      int *p = (int*)malloc(2 * sizeof(double));//编译无错误
      ```

    - new封装了malloc，直接free不会报错，但是只是释放内存，而不会析构对象

    - new调用名为**operator new的标准库函数**分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为**operator delete的标准库函数**释放该对象所用内存。后者均没有相关调用

    - malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。

    - malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

  - **delete和delete[]区别？**

    - delete只会调用一次析构函数。 delete[]会调用数组中每个元素的析构函数。

  

- [x] 为什么需要分虚函数和纯虚函数
  1. 虚函数和纯虚函数都可以在子类中被重写，**前者既有定义也有实现代码，后者一般没有实现的代码**
  2. 含有纯虚函数的类不能实例化，也就是只能被继承到子类中去实现，含有此函数的类被称为抽象类。**另外虚函数在子类中可以不重载，但是纯虚函数必须重载**
  3. 含有纯虚函数的类一般用于定义一些公有的方法



- [x] 智能指针了解吗
  1. 原理：是一个类，存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源
  2. 常用的智能指针：
     1. **shared_ptr**
     2. **unique_ptr**
     3. **weak_ptr**
     4. **auto_ptr**



#### 数据库

1. 如何优化查询过程
2. **left join**和**right join**区别
3. [联合索引](https://blog.csdn.net/lm1060891265/article/details/81482328)了解吗
   1. 指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.
   2. 优化：在联合索引中将选择性最高的列放在索引最前面。

- [x] **乐观锁和悲观锁了解吗**

  参考[ByteDanceGuide.md](https://github.com/EricPengShuai/Interview/blob/main/Guide/ByteDanceGuide.md#5-简述乐观锁以及悲观锁的区别以及使用场景)



#### 计算机网络

1. 网页请求过程



#### 操作系统

1. **死锁**了解吗
2. **进程和线程**区别：进程是分配资源单位，线程是调度单位

- [x] 虚拟内存了解吗，相比于使用物理内存的优点在哪

  - 虚拟内存的目的是为了**让物理内存扩充成更大的逻辑内存**，从而让程序获得更多的可用内存。

  - 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。**这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。**当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

  - 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说**一个程序不需要全部调入内存就可以运行**，这使得有限的内存运行大程序成为可能。

    > 例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。



#### 算法

1. 一串数字任意排列，处理一下，奇数在前升序，偶数在后逆序
   - 当时有点紧张，只完成了80%，那个sort的自定义排序还是不熟悉啊

2. 海量数据100G选择TOP 100个单词：注意只需要选取每个文件中前100个单词，然后再归并



### 用户质量效能部

> 2021.6.4 测试开发工程师
>
> HR以为是补录，结果面试官没有面
## 弹性计算

### 计算调度团队

#### 一面

> 2023.02.13

- 介绍团队主要的业务，主要是Java/Python，C/C++ 占 1/3 

- 聊项目，30min

##### 八股

1、数据库中的 transaction

2、Python 中的协程和线程，不太了解

- 进程(Process)：进程是计算机中的程序关于某数据集合的一次运行实例，是操作系统进行**资源分配**的最小单位
- 线程(Thread)：线程被包含在进程之中，是操作系统进行**程序调度**执行的最小单位
- 协程(Coroutine)：协程是**用户态**执行的轻量级编程模型，由单一线程内部发出控制信号进行调度

协程由单一线程内部发出控制信号进行调度，而非受到操作系统管理，因此**协程没有切换开销和同步锁机制**，具有极高的执行效率。

**协程常用于IO密集型工作**，例如网络资源请求等；而**进程、线程常用于计算密集型工作**，例如科学计算、人工神经网络等。、

> 参考：https://blog.csdn.net/FRIGIDWINTER/article/details/124369567



##### 算法

> 60min + 30min

1、三数之和：[15. 三数之和](https://leetcode.cn/problems/3sum/)

2、根据上排给出0,1,2 …… n个数(n >= 3)组成的等差数列 ,在其下排填出对应的n+1个数, 要求下排每个数都是先前上排对应那个数在下排数中出现的次数 , 如：

```cpp
// 1和2下面的数永远是2和1，0下面对应的数为n-3（n>=6），上排数n-3下面对应的数为1，其它上排数下面对应为0就ok了
// n = 9
0 1 2 3 4 5 6 7 8 9
6 2 1 0 0 0 1 0 0 0
// n = 10
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
16 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
// n = 6
0 1 2 3 4 5 6
3 2 1 1 0 0 0

// n = 3
0 1 2 3
1 2 1 0  
// n = 4
0 1 2 3 4
2 1 2 0 0
// n = 5 无解
```

代码求解：只能求解 `n=3` 以及 `n>=6` 的情况，无法求解 n=4/5 的情况

```cpp
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

class NumberTB {
    int len;
    bool success;
    vector<int> top;
    vector<int> bottom;

public:
    NumberTB(int n) {
        len = n < 3 ? 3 : n+1;
        success = false;
        top = vector<int>(len, 0);
        bottom = vector<int>(len, 0);
        
        // 赋初始值 0 1 2 3 ... n
        iota(top.begin(), top.end(), 0);
    }

    vector<int> getBottom() {
        int id = 0;
        while(!success) {
            success = true;
            for (int i = 0; i < len; ++ i) {
                int frequency = getFrequency(top[i]);
                if (bottom[i] != frequency) {
                    bottom[i] = frequency;
                    success = false;
                }
            }
            cout << "第 " << id++ << " 次尝试：";
            for (auto& b: bottom) {
                cout << b << ' ';
            }
            cout << endl;
        }
        return bottom;
    }

    // 计算 num 在 bottom 中出现的次数
    int getFrequency(int num) {
        int cnt = 0;
        for (int i = 0; i < len; ++ i) {
            if (bottom[i] == num) {
                ++ cnt;
            }
        }
        return cnt;
    }
};

int main()
{
    int n;
    cin >> n;
    NumberTB tb(n);
    vector<int> p = tb.getBottom();

    for (int i = 0; i <= n; ++ i) cout << i << ' ';
    cout << endl;
    
    for (auto& x: p) cout << x << ' ';
    cout << endl;
    return 0;
}
```



#### 二面

> 2023.02.15

- 介绍自己的技术栈以及聊项目，25min

##### 八股

- 进程、线程、协程区别？

> 这个问题一面也问了，调度团队问的频率还挺高？

##### 场景题

> 和部门很相关

1、重新开始学一门，多久能学会？

2、很多请求分配给10个服务器，如何分配

- 加一个**负载均衡**
- 负载均衡的算法有哪些？
  - **轮询**：负载均衡系统接收到请求后，**按照顺序轮流分配给服务器**。这种方式非常简单，只管按顺序分配，至于服务器当前负载情况、硬件能力等都不关心，只要服务器还能工作，就可以分配，除非服务器挂了。
  - **加权轮询**：是轮询方式的一种改进，轮询方式是无差别分配，但实际服务器的处理能力是有差异的，所以需要区别对待。**为服务器设置权值，权值高的就多分配点**。
  - **负载最低优先**：将任务分配给当前负载最低的服务器。例如 LVS 可以根据“连接数”判断服务器状态，**NGINX 可以根据“HTTP请求数”来判断**。这种方式比轮询高级很多，可以感知服务器的状态了，但其复杂度也大大提高了，要收集统计服务器的负载信息。
  - **性能最优**：优先将任务分配给**处理速度最快的服务器**，来达到最快响应客户端的目的。此方式也是感知服务器的状态，标准是**响应时间**。需要收集分析服务器的响应时间，这个工作本身消耗也不小，所以采用**采样**的方式，不统计所有任务的响应时间，统计一个周期（例如 10秒/1分钟/5分钟）内的状态。优缺点与 *负载最低优先* 相同。
  - **Hash**：**对请求中的关键信息（如IP）进行hash计算**，hash 值相同的请求分配到同一台服务器，例如业务中希望同一用户的请求都由同一台服务器来处理。



## 云网络

### 广域网团队

> 主要是路由设备中数据包的转发，主要语言是 C/Go/Python

#### 一面

> 2023.02.15

- 聊项目：30min
- 八股问了很多计网的知识点，基本忘了

##### 八股

**1、OSI 7层模型以及 TCP/IP 协议层**

**2、数据链路层、网络层、传输层具体负责什么工作，有哪些协议** :fire:

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为**报文**。
- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成**分组**。[IP协议、ICMP协议（网际控制报文协议）、IGMP协议（组管理协议）、ARP协议（地址解析协议）、RARP协议、OSPF（开放的最短路径优先协议）]
- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成**帧**。[点对点协议（PPP），高级链路控制协议（HDLC）]
- **物理层** ：考虑的是怎样在传输媒体上传输数据**比特流**，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

> [各层网络协议实例详解：物理层、连接层、网络层、传输层、应用层](https://blog.csdn.net/yunxiu988622/article/details/105306012)

**3、IP 地址是什么和什么之间的通信，端口号作用？**

在计算机中，IP地址是分配给网卡的，每个网卡有一个唯一的IP地址，如果一个计算机有多个网卡，则该台计算机则拥有多个不同的IP地址，在同一个网络内部，IP地址不能相同。

由于IP地址不方便记忆，所以有专门创造了域名(Domain Name)的概念，其实就是给IP取一个字符的名字，例如163.com、sina.com等。IP和域名之间存在一定的对应关系。

那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。

所以在网络编程中，可以使用IP或域名来标识网络上的一台设备。为了在一台设备上可以运行多个程序，人为的设计了端口(Port)的概念，类似的例子是公司内部的分机号码。规定一个设备有216个，也就是65536个端口，每个端口对应一个唯一的程序。

> [理解IP地址和端口号-CSDN博客_ip 和端口号](https://blog.csdn.net/luckyaslan/article/details/7745245)

**4、TCP、UDP的区别** :fire:

- 无连接和面向连接
- 用途场景
- 拥塞控制

**5、路由选择算法**

- 自治区域内部：内部网关协议 IGP (Interior Gateway Protocol)
  - RIP (Routing Information Protocol)：距离矢量协议，使用“跳数”来衡量到达目标地址的路由距离，有 15 跳的限制，所以只适用于小区域，**RIP 用 UDP 数据报传送**
  - OSPF (Open Shortest Path First)：链路状态协议，使用“带宽”、“延迟”作为度量标准，使用 Dijkstra 算法找最短路径，**OSPF 直接用 IP 数据报传送**
- 自治区域外部：外部网关协议 EGP (External Gateway Protocol)
  - BGP (Border Gateway Protocol)：边界网关路由协议是一种用于自治系统之间的外部网关协议。其功能是同其他的BGP系统交换网络可达信息，实现自治系统间无环路的路由信息交换。BGP的最新版本是BGP版本4(BGP-4)，它支持无类域间路由(CIDR)并使用路由聚合机制减小路由表的尺寸。在路由协议中，**只有BGP使用TCP作为传输层协议**

> [路由选择协议 RIP、OSPF、BGP 详解-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1671821)
>
> [路由选择协议(RIP/OSPF)_-CSDN博客_路由选择协议](https://blog.csdn.net/qq_36119192/article/details/84225257)

**6、如何查找路由表中的目的路由表项，IP 最长匹配算法** :fire:

将 **目的IP** 与 **子网掩码** 相与，取最长匹配的表项，如果表项很大，可以先使用**二叉线索树**查找路由表

> [网络层中查找路由表的过程（图文详解）路由表查找规则](https://blog.csdn.net/qq1350975694/article/details/106948945)
>
> [无分类编址 CIDR（构造超网） - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1671928)

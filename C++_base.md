## C++ 本科课程总结

### 1. 概述

1. 类和对象关系是抽象和具体关系，对象是类的一个实例
2. OO基本特征：抽象、封装、继承、多态
   1. 抽象：对具体问题进行概括，抽出这一类对象的公共性质并且加一描述，包括数据抽象和行为抽象
   2. 封装：将抽象出的数据成员、行为成员相结合，将它们形成一个整体，访问权限的控制、部分成员充当外部接口
   3. 继承：实现代码的重用，被继承的已有类称为基类或父类
   4. 派生：在已有类的基础上新增自己的特性

3. 多态：同一名称，不同的功能实现方式，达到行为标识同一减少程序中标识符的个数
   1. 函数重载：形参个数或者类型不同
   2. 运算符重载：比如可以实现字符串相加
   3. 虚函数：使用关键字`virtual`声明，在基类中申明一些能够在派生类中重新定义的函数

### 2. 语言基础

1. 各种数据类型：字符型有单和宽之分，构造类型有结构类型`struct`、联合型`union`、枚举类型`enum`，比较重要的有**类类型**`class`

   - 前面可以加各种修饰符
   - 扩展类型如`struct`、`union`、`enum`可以被看成特殊的类

2. 常量`const`：在定义时或对象创建时，必须要进行初始化，之后在生命周期只读，不可以被修改，使用`define`定义常量不经过编译器进行类型检查，而`const`需要

3. 变量：不要随意定义全局变量或堆变量，尽量使用局部变量或栈变量。

   1. ##### [堆和栈的区别是什么？](https://www.cnblogs.com/cchHers/p/10010275.html)

   2. 内存分为5个区：

      - 栈：由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区，通常是局部变量、函数参数等。
      - 堆：由`new`分配的内存块，他们的释放编译器不管，由应 用程序控制，一般一个`new`就要对应一个`delete`释放内存。
      - 自由存储区：由`malloc`等分配的内存块，和堆十分相似，不过是通过`free`来释放内存。
      - 静态存储区：全局变量和静态变量被分配在该存储区中。
      - 常量存储区：用于存放不能修改的常量，比如字符串常量 ，数字常量等。

4. 运算符和表达式：`&、 |、 ^、 ~`分别代表`与、或、异或、非`

5. 控制结构：顺序结构、分支结构、循环结构

6. ``inline``函数：在编译时调用内联函数的地方被函数体替换，减少函数调用所需的参数传递、控制转移等开销

   1. 典型的空间换时间的手段
   2. 内联函数定义必须出现在第一次被调用之前

7. 引用`&`
8. 数组、指针变量、void类型指针的值（地址）可赋值给任何类型的指针变量但是需要强制类型转换
9. 指向常量的指针和和常量指针

### 3. 类和对象

1. 三种成员类型
   1. 公有成员：作为类与外部的接口
   2. 私有成员：只有本类中的函数可以访问，派生类不可以访问
   3. 保护类型：允许本类和派生类的成员访问
2. 构造函数：名字和类名相同，在创建对象时系统自动调动，可以有多个
3. 析构函数：在对象的生存期结束的时刻系统自动调用它， 然后再释放此对象所属的空间；如果未声明析构函数编译器自动产生一个默认的；基类析构函数不能被派生类继承
4. 拷贝构造函数：用类的一个对象初始化该类的另一个对象
5. `new`分配内存：`int *a = new int [5]`，`delete`销毁对象：`delete [] a`
6. 组合类构造函数和析构函数调用顺序
7. `this`指针隐含于类的成员函数中，指向正在被成员函数操作的对象
8. 友元函数：一种破坏数据封装和数据隐藏的机制
9. 静态数据成员

### 4. 派生类和继承

1. 继承方式：默认时私有继承（全部变成私有），公有继承，保护继承
2. 派生类：不能继承基类的构造函数和析构函数，有单继承、多继承、直接基类、间接基类说法
3. 多继承基类会有二义性问题：类名限定或者同名隐藏



## C++ Things

### 1. const

- **作用**

  - 定义常量，防止变量修改，增加程序的健壮性
  - 节省空间，避免不必要的内存分配：const定义的常量在程序中只有一份拷贝，#define定义的常量在内存中有若干个拷贝

- const对象访问在不同文件访问时需要加extern关键字

- const常量定义时需要初始化，所以：`const i,j = 0;` 是不对的

- **指针**

  ```cpp
  const char * a;	// 指向const对象的指针或者是指向常量的指针
  char const * a;	// 同上
  char * const a;	// 指向字符对象的const指针，常指针
  const char * const a;	// 指向const字符对象的const指针
  ```

- 函数中使用const：[重点看一下](https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/const#6%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8const)

- 类中使用const：[关注看一下](https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/const#7%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8const)
  - const对象只能访问const成员函数
  - 非const对象可以访问所有的成员函数

### 2. static

- 静态变量：静态变量的空间只分配一次；类中的静态变量被实例化对象共享，所以类中的静态变量不能使用构造函数初始化

- 静态成员：类对象为静态时，一直到程序结束时才会被销毁；类中静态函数可以访问静态成员数据以及其他静态成员函数，无法访问类的非静态数据成员或成员函数，**注意一下访问方式**

  ```c++
  #include<iostream> 
  using namespace std; 
  
  class Apple 
  { 
      public: 
          static void printMsg() 
          {
              cout<<"Welcome to Apple!"; 
          }
  }; 
  
  int main() 
  { 
      Apple::printMsg(); // invoking a static member function 
  } 
  ```


### 3. this指针

- 作用：
  1. 一个对象的this指针不是对象本身的一部分
  2. this作用域在类内部，在类的非静态成员函数中访问类的非静态成员时，编译器会自动将对象本身的地址作为一个隐含参数传递给函数

- 使用：当参数与成员变量名相同时，使用`this->n = n`



### 4. inline

**内联函数是以代码膨胀（复制）为代价提升函数执行效率的**

编译器处理内联函数步骤：

- 将`inline`函数体复制到`inline`函数调用点处
- 为所用`inline`函数中的局部变量分配内存空间
- 将`inline`函数的输入参数和返回值映射到调用方法的局部变量空间中
- 如果`inline`函数有多个返回点，将它转变为`inline`函数代码块末尾的分支

> 虚函数可以是内联函数，但是当虚函数表现多态性时不能内联（因为多态性是在运行期，内存是在编译期）
>
> 参考代码：[/base_code/inline/main.cpp](/base_code/inline/main.cpp)

- [ ] 修改文件名称



### 5. sizeof

- 空类的大小为1字节
- 类中的虚函数、成员函数、静态数据成员都不占用类对象的存储空间，**即使类中有多个虚函数，但是只有一个虚指针**
- 虚函数继承都是继承基类的vptr

> 参考代码 ：[/base_code/sizeof/main.cpp](/base_code/sizeof/main.cpp)



### 6. 纯虚函数和抽象类

#### 纯虚函数

- 只需要声明，不需要实现
- 包含纯虚函数的类就是抽象类，抽象类只能作为基类使用，**不能创建抽象类对象**，但是可以定义抽象类的指针



#### 抽象类

- **抽象类中成员函数可以调用纯虚函数，但是构造函数/析构函数内部不能使用纯虚函数**
- 如果一个类中集成抽象类，它只有实现实现了抽象类中所有的纯虚函数之后才能成为非抽象类



> 构造函数不能是虚函数，但是析构函数可以是虚函数

